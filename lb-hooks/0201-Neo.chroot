#!/bin/bash
set -euo pipefail
export DEBIAN_FRONTEND=noninteractive

echo "[neo-ai] === Neo Assistant Enhanced Personal AI System ==="

# ------------------------------------------------------------
# 1. Remove telemetry (live system)
# ------------------------------------------------------------
echo "[neo-ai] Removing telemetry from live system‚Ä¶"
apt-get purge -y --auto-remove \
  popularity-contest whoopsie apport apport-gtk apport-kde \
  gnome-online-accounts zeitgeist-core tracker \
  tracker-miner-fs tracker-extract || true
systemctl disable whoopsie.service apport.service || true
rm -f /etc/xdg/autostart/gnome-software-service.desktop || true

# ------------------------------------------------------------
# 2. Install dependencies + Docker + Ollama
# ------------------------------------------------------------
apt-get update
apt-get install -y --no-install-recommends \
  curl ca-certificates gnupg lsb-release \
  python3 python3-venv python3-pip python3-gi \
  xdg-utils jq git unzip \
  libxcb-cursor0 libxkbcommon0 libxkbcommon-x11-0 \
  libgl1 libglib2.0-0 libdbus-1-3 \
  qt6-base-dev qt6-base-dev-tools \
  sqlite3 nodejs npm

# Install Docker
if ! command -v docker >/dev/null 2>&1; then
  echo "[neo-ai] Installing Docker‚Ä¶"
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
  apt-get update
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
  systemctl enable docker
  usermod -aG docker cyber || true
fi

# Install Ollama
if ! command -v ollama >/dev/null 2>&1; then
  echo "[neo-ai] Installing Ollama runtime‚Ä¶"
  curl -fsSL https://ollama.com/install.sh | sh
fi
systemctl enable ollama.service || true

# ------------------------------------------------------------
# 3. Setup MCP Server with Docker
# ------------------------------------------------------------
echo "[neo-ai] Setting up MCP Server infrastructure‚Ä¶"
install -d -m 0755 /opt/neo-mcp
cd /opt/neo-mcp

# MCP Server Docker Compose
cat >docker-compose.yml <<'COMPOSE'
version: '3.8'

services:
  mcp-server:
    image: mcphost/server:latest
    container_name: neo-mcp-server
    restart: unless-stopped
    ports:
      - "3000:3000"
      - "8080:8080"
    environment:
      - MCP_HOST=0.0.0.0
      - MCP_PORT=3000
      - WEB_PORT=8080
      - NODE_ENV=production
    volumes:
      - ./config:/app/config
      - ./data:/app/data
      - ./plugins:/app/plugins
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - neo-network

  postgres:
    image: postgres:15-alpine
    container_name: neo-postgres
    restart: unless-stopped
    environment:
      - POSTGRES_DB=neo_ai
      - POSTGRES_USER=neo
      - POSTGRES_PASSWORD=secure_neo_pass_2024
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./sql:/docker-entrypoint-initdb.d
    ports:
      - "5432:5432"
    networks:
      - neo-network

  redis:
    image: redis:7-alpine
    container_name: neo-redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass secure_redis_pass_2024
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - neo-network

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: neo-elasticsearch
    restart: unless-stopped
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - neo-network

volumes:
  postgres_data:
  redis_data:
  elasticsearch_data:

networks:
  neo-network:
    driver: bridge
COMPOSE

# MCP Configuration
install -d -m 0755 config data plugins sql
cat >config/mcp-config.json <<'MCP_CONFIG'
{
  "version": "1.0",
  "name": "Neo AI MCP Server",
  "capabilities": {
    "tools": true,
    "resources": true,
    "prompts": true,
    "logging": true
  },
  "tools": [
    {
      "name": "web_search",
      "description": "Search the web for current information",
      "schema": {
        "type": "object",
        "properties": {
          "query": {"type": "string"},
          "limit": {"type": "number", "default": 10}
        }
      }
    },
    {
      "name": "file_operations",
      "description": "Read, write, and manage files",
      "schema": {
        "type": "object",
        "properties": {
          "action": {"type": "string", "enum": ["read", "write", "delete", "list"]},
          "path": {"type": "string"},
          "content": {"type": "string"}
        }
      }
    },
    {
      "name": "system_info",
      "description": "Get system information and status",
      "schema": {
        "type": "object",
        "properties": {
          "component": {"type": "string", "enum": ["cpu", "memory", "disk", "network", "processes"]}
        }
      }
    },
    {
      "name": "code_analysis",
      "description": "Analyze and suggest improvements for code",
      "schema": {
        "type": "object",
        "properties": {
          "code": {"type": "string"},
          "language": {"type": "string"},
          "analysis_type": {"type": "string", "enum": ["syntax", "security", "performance", "style"]}
        }
      }
    }
  ],
  "resources": [
    {
      "uri": "file://",
      "name": "Local Files",
      "description": "Access to local file system"
    },
    {
      "uri": "postgres://neo:secure_neo_pass_2024@postgres:5432/neo_ai",
      "name": "Database",
      "description": "PostgreSQL database connection"
    },
    {
      "uri": "redis://default:secure_redis_pass_2024@redis:6379",
      "name": "Cache",
      "description": "Redis cache and session storage"
    },
    {
      "uri": "http://elasticsearch:9200",
      "name": "Search Engine",
      "description": "Elasticsearch for document indexing and search"
    }
  ],
  "security": {
    "api_key_required": false,
    "cors_enabled": true,
    "rate_limiting": {
      "enabled": true,
      "requests_per_minute": 100
    }
  }
}
MCP_CONFIG

# Database initialization
cat >sql/init.sql <<'SQL'
CREATE TABLE IF NOT EXISTS conversations (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) DEFAULT 'cyber',
    title VARCHAR(500),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    tokens INTEGER DEFAULT 0,
    model_used VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS knowledge_base (
    id SERIAL PRIMARY KEY,
    title VARCHAR(500),
    content TEXT,
    source VARCHAR(500),
    tags TEXT[],
    embedding VECTOR(1536),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS user_preferences (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) DEFAULT 'cyber',
    key VARCHAR(255) NOT NULL,
    value JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, key)
);

CREATE TABLE IF NOT EXISTS system_metrics (
    id SERIAL PRIMARY KEY,
    metric_type VARCHAR(100),
    metric_value JSONB,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_messages_conversation ON messages(conversation_id);
CREATE INDEX idx_messages_created ON messages(created_at);
CREATE INDEX idx_knowledge_tags ON knowledge_base USING GIN(tags);
CREATE INDEX idx_user_prefs ON user_preferences(user_id, key);
SQL

# Start MCP services
docker compose up -d

# ------------------------------------------------------------
# 4. Enhanced Neo Assistant Application
# ------------------------------------------------------------
echo "[neo-ai] Installing Enhanced Neo Assistant‚Ä¶"
install -d -m 0755 /usr/local/neo-assistant
install -d -m 0755 /etc/neo-assistant
install -d -m 0755 /usr/share/applications
install -d -m 0755 /usr/share/icons/hicolor/64x64/apps

# Enhanced Policy Configuration
cat >/etc/neo-assistant/policy.yaml <<'YAML'
core:
  model: phi3.5:latest
  fallback_models: ["llama3.1:8b", "qwen2.5:7b", "deepseek-coder:6.7b"]
  temperature: 0.7
  top_p: 0.9
  max_tokens: 4096
  context_window: 32768

personality:
  name: "Neo"
  role: "Advanced Personal AI Assistant"
  traits: ["helpful", "analytical", "creative", "proactive", "secure"]
  response_style: "conversational"
  humor_level: 0.3

mcp:
  server_url: "http://localhost:3000"
  api_key: null
  timeout: 30
  retry_attempts: 3
  
capabilities:
  web_search: true
  file_operations: true
  code_analysis: true
  system_monitoring: true
  voice_input: false
  voice_output: false
  screen_capture: true
  automation: true

memory:
  db_path: "~/.local/share/neo-assistant/neo.db"
  max_conversations: 1000
  max_messages_per_conversation: 500
  context_retention_days: 30
  auto_summarize: true

privacy:
  offline_first: true
  telemetry_disabled: true
  encryption_at_rest: true
  pii_detection: true
  data_retention_days: 365

ui:
  theme: "dark"
  transparency: 0.95
  auto_hide: true
  hotkey: "Super+Shift+N"
  tray_enabled: true
  notifications: true

integrations:
  postgres_url: "postgresql://neo:secure_neo_pass_2024@localhost:5432/neo_ai"
  redis_url: "redis://default:secure_redis_pass_2024@localhost:6379"
  elasticsearch_url: "http://localhost:9200"
YAML

# Modern icon
cat >/usr/share/icons/hicolor/64x64/apps/neo-assistant.svg <<'SVG'
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <defs>
    <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#1e3a8a;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#3730a3;stop-opacity:1" />
    </linearGradient>
    <linearGradient id="accent" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#10b981;stop-opacity:1" />
    </linearGradient>
  </defs>
  <rect width="64" height="64" rx="16" fill="url(#bg)"/>
  <circle cx="20" cy="24" r="2.5" fill="url(#accent)"/>
  <circle cx="32" cy="24" r="2.5" fill="url(#accent)"/>
  <circle cx="44" cy="24" r="2.5" fill="url(#accent)"/>
  <path d="M18 35 Q32 42 46 35" stroke="url(#accent)" stroke-width="3" fill="none" stroke-linecap="round"/>
  <circle cx="32" cy="48" r="3" fill="#22d3ee" opacity="0.6"/>
</svg>
SVG

# Python application with enhanced features
python3 - <<'PY'
import os, subprocess, textwrap
base = "/usr/local/neo-assistant"
venv = f"{base}/venv"
os.makedirs(base, exist_ok=True)

if not os.path.exists(venv):
    subprocess.check_call(["python3", "-m", "venv", venv])

pip = f"{venv}/bin/pip"
packages = [
    "PyQt6", "requests", "pyyaml", "beautifulsoup4", "psycopg2-binary",
    "redis", "elasticsearch", "cryptography", "pillow", "nltk",
    "sentence-transformers", "numpy", "pandas", "matplotlib"
]
subprocess.check_call([pip, "install", "--no-cache-dir"] + packages)

# Main enhanced application
open(f"{base}/neo_assistant.py", "w").write(textwrap.dedent(r'''
import os, sys, json, sqlite3, time, requests, re, threading, hashlib
from pathlib import Path
from datetime import datetime, timedelta
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QRect
from PyQt6.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, 
                           QLineEdit, QTextEdit, QPushButton, QSystemTrayIcon, 
                           QMenu, QAction, QLabel, QTabWidget, QListWidget, 
                           QSplitter, QFrame, QScrollArea, QComboBox, QCheckBox)
from PyQt6.QtGui import QIcon, QFont, QTextCharFormat, QColor, QPalette, QPixmap
import yaml, psycopg2, redis, requests
from bs4 import BeautifulSoup
from cryptography.fernet import Fernet

CONFIG = "/etc/neo-assistant/policy.yaml"
cfg = yaml.safe_load(open(CONFIG))

# Initialize encryption
key_file = os.path.expanduser("~/.local/share/neo-assistant/encryption.key")
os.makedirs(os.path.dirname(key_file), exist_ok=True)
if not os.path.exists(key_file):
    key = Fernet.generate_key()
    with open(key_file, 'wb') as f:
        f.write(key)
else:
    with open(key_file, 'rb') as f:
        key = f.read()
cipher = Fernet(key)

# Database setup
data_path = os.path.expanduser(cfg["memory"]["db_path"])
os.makedirs(os.path.dirname(data_path), exist_ok=True)
conn = sqlite3.connect(data_path, check_same_thread=False)
cur = conn.cursor()

# Enhanced schema
cur.execute("""CREATE TABLE IF NOT EXISTS conversations 
               (id INTEGER PRIMARY KEY, title TEXT, created_at INTEGER, updated_at INTEGER)""")
cur.execute("""CREATE TABLE IF NOT EXISTS messages 
               (id INTEGER PRIMARY KEY, conversation_id INTEGER, role TEXT, 
                content TEXT, tokens INTEGER, model_used TEXT, created_at INTEGER,
                FOREIGN KEY (conversation_id) REFERENCES conversations (id))""")
cur.execute("""CREATE TABLE IF NOT EXISTS knowledge_base 
               (id INTEGER PRIMARY KEY, title TEXT, content TEXT, source TEXT, 
                tags TEXT, embedding BLOB, created_at INTEGER)""")
cur.execute("""CREATE TABLE IF NOT EXISTS user_preferences 
               (id INTEGER PRIMARY KEY, key TEXT UNIQUE, value TEXT, created_at INTEGER)""")
cur.execute("""CREATE TABLE IF NOT EXISTS system_metrics 
               (id INTEGER PRIMARY KEY, metric_type TEXT, metric_value TEXT, recorded_at INTEGER)""")
conn.commit()

# MCP Integration
class MCPClient:
    def __init__(self, base_url="http://localhost:3000"):
        self.base_url = base_url
        self.session = requests.Session()
    
    def call_tool(self, tool_name, **kwargs):
        try:
            response = self.session.post(f"{self.base_url}/tools/{tool_name}", 
                                       json=kwargs, timeout=30)
            return response.json() if response.status_code == 200 else None
        except:
            return None
    
    def web_search(self, query, limit=10):
        return self.call_tool("web_search", query=query, limit=limit)
    
    def analyze_code(self, code, language, analysis_type="syntax"):
        return self.call_tool("code_analysis", code=code, 
                            language=language, analysis_type=analysis_type)
    
    def get_system_info(self, component="cpu"):
        return self.call_tool("system_info", component=component)

mcp = MCPClient()

def encrypt_content(content):
    if cfg["privacy"]["encryption_at_rest"]:
        return cipher.encrypt(content.encode()).decode()
    return content

def decrypt_content(encrypted_content):
    if cfg["privacy"]["encryption_at_rest"]:
        try:
            return cipher.decrypt(encrypted_content.encode()).decode()
        except:
            return encrypted_content
    return encrypted_content

def save_message(conversation_id, role, content, model_used="phi3.5:latest"):
    encrypted_content = encrypt_content(content)
    cur.execute("""INSERT INTO messages(conversation_id, role, content, tokens, model_used, created_at) 
                   VALUES(?,?,?,?,?,?)""", 
                (conversation_id, role, encrypted_content, len(content.split()), 
                 model_used, int(time.time())))
    conn.commit()

def get_conversation_history(conversation_id, limit=100):
    cur.execute("""SELECT role, content FROM messages 
                   WHERE conversation_id=? ORDER BY id ASC LIMIT ?""", 
                (conversation_id, limit))
    messages = []
    for role, encrypted_content in cur.fetchall():
        content = decrypt_content(encrypted_content)
        messages.append({"role": role, "content": content})
    return messages

def strip_pii(text):
    if not cfg["privacy"]["pii_detection"]:
        return text
    
    # Enhanced PII detection
    patterns = [
        (r'\b[\w\.-]+@[\w\.-]+\.\w+\b', '[EMAIL]'),
        (r'\b\d{3}-\d{2}-\d{4}\b', '[SSN]'),
        (r'\b\d{10,16}\b', '[PHONE/CC]'),
        (r'\b\d{1,5}\s+([A-Za-z]+\s+){1,3}(Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln)\b', '[ADDRESS]'),
        (r'\b(19|20)\d{2}[-/](0[1-9]|1[0-2])[-/](0[1-9]|[12][0-9]|3[01])\b', '[DATE]')
    ]
    
    for pattern, replacement in patterns:
        text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)
    return text

class ModelThread(QThread):
    response_chunk = pyqtSignal(str)
    response_complete = pyqtSignal(str)
    
    def __init__(self, messages, conversation_id):
        super().__init__()
        self.messages = messages
        self.conversation_id = conversation_id
        self.model = cfg["core"]["model"]
    
    def run(self):
        try:
            # Try primary model first
            response = self.stream_ollama(self.messages, self.model)
            if response:
                save_message(self.conversation_id, "assistant", response, self.model)
                self.response_complete.emit(response)
                return
            
            # Fallback to other models
            for fallback_model in cfg["core"]["fallback_models"]:
                try:
                    response = self.stream_ollama(self.messages, fallback_model)
                    if response:
                        save_message(self.conversation_id, "assistant", response, fallback_model)
                        self.response_complete.emit(response)
                        return
                except:
                    continue
            
            self.response_complete.emit("I apologize, but I'm having trouble connecting to the AI models right now.")
            
        except Exception as e:
            self.response_complete.emit(f"Error: {str(e)}")
    
    def stream_ollama(self, messages, model):
        try:
            url = "http://127.0.0.1:11434/api/chat"
            payload = {
                "model": model,
                "messages": messages,
                "options": {
                    "temperature": cfg["core"]["temperature"],
                    "top_p": cfg["core"]["top_p"],
                    "num_ctx": cfg["core"]["context_window"]
                }
            }
            
            response = requests.post(url, json=payload, stream=True, timeout=60)
            full_response = ""
            
            for line in response.iter_lines():
                if not line:
                    continue
                
                try:
                    data = json.loads(line.decode("utf-8"))
                    if "message" in data and "content" in data["message"]:
                        chunk = data["message"]["content"]
                        full_response += chunk
                        self.response_chunk.emit(chunk)
                        
                    if data.get("done", False):
                        break
                except json.JSONDecodeError:
                    continue
            
            return full_response
        except Exception as e:
            print(f"Ollama error: {e}")
            return None

class NeoMainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.current_conversation_id = self.create_new_conversation()
        self.setup_ui()
        self.setup_tray()
        self.setup_styling()
        
    def setup_ui(self):
        self.setWindowTitle("Neo AI Assistant")
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.resize(1200, 800)
        
        # Main layout with tabs
        main_layout = QVBoxLayout(self)
        
        # Tab widget
        self.tabs = QTabWidget()
        
        # Chat tab
        chat_widget = QWidget()
        chat_layout = QVBoxLayout(chat_widget)
        
        # Splitter for conversations and chat
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Conversations list
        self.conversations_list = QListWidget()
        self.conversations_list.setMaximumWidth(300)
        self.load_conversations()
        self.conversations_list.itemClicked.connect(self.switch_conversation)
        
        # Chat area
        chat_area = QWidget()
        chat_area_layout = QVBoxLayout(chat_area)
        
        # Chat display
        self.chat_display = QTextEdit()
        self.chat_display.setReadOnly(True)
        
        # Input area
        input_layout = QHBoxLayout()
        self.input_field = QLineEdit()
        self.input_field.setPlaceholderText("Ask Neo anything... (Type 'search:' for web search, 'code:' for analysis)")
        self.send_button = QPushButton("Send")
        
        input_layout.addWidget(self.input_field)
        input_layout.addWidget(self.send_button)
        
        chat_area_layout.addWidget(self.chat_display)
        chat_area_layout.addLayout(input_layout)
        
        splitter.addWidget(self.conversations_list)
        splitter.addWidget(chat_area)
        
        chat_layout.addWidget(splitter)
        
        # Settings tab
        settings_widget = QWidget()
        settings_layout = QVBoxLayout(settings_widget)
        
        self.model_selector = QComboBox()
        self.model_selector.addItems(["phi3.5:latest", "llama3.1:8b", "qwen2.5:7b", "deepseek-coder:6.7b"])
        
        self.privacy_mode = QCheckBox("Enhanced Privacy Mode")
        self.privacy_mode.setChecked(cfg["privacy"]["pii_detection"])
        
        self.auto_search = QCheckBox("Auto Web Search")
        self.auto_search.setChecked(cfg["capabilities"]["web_search"])
        
        settings_layout.addWidget(QLabel("Primary Model:"))
        settings_layout.addWidget(self.model_selector)
        settings_layout.addWidget(self.privacy_mode)
        settings_layout.addWidget(self.auto_search)
        settings_layout.addStretch()
        
        # Add tabs
        self.tabs.addTab(chat_widget, "Chat")
        self.tabs.addTab(settings_widget, "Settings")
        
        main_layout.addWidget(self.tabs)
        
        # Connect signals
        self.input_field.returnPressed.connect(self.send_message)
        self.send_button.clicked.connect(self.send_message)
    
    def setup_styling(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                color: #ffffff;
                font-family: 'SF Pro Display', 'Segoe UI', sans-serif;
            }
            QLineEdit {
                background-color: #2d2d30;
                border: 2px solid #007acc;
                border-radius: 8px;
                padding: 8px;
                font-size: 14px;
            }
            QPushButton {
                background-color: #007acc;
                border: none;
                border-radius: 8px;
                padding: 8px 16px;
                font-weight: bold;
                color: white;
            }
            QPushButton:hover {
                background-color: #005a9e;
            }
            QTextEdit {
                background-color: #252526;
                border: 1px solid #3c3c3c;
                border-radius: 8px;
                padding: 12px;
                font-size: 13px;
                line-height: 1.4;
            }
            QListWidget {
                background-color: #252526;
                border: 1px solid #3c3c3c;
                border-radius: 8px;
            }
            QTabWidget::pane {
                border: 1px solid #3c3c3c;
                border-radius: 8px;
            }
            QTabBar::tab {
                background-color: #2d2d30;
                padding: 8px 16px;
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;
            }
            QTabBar::tab:selected {
                background-color: #007acc;
            }
        """)
    
    def create_new_conversation(self):
        timestamp = int(time.time())
        cur.execute("INSERT INTO conversations(title, created_at, updated_at) VALUES(?,?,?)",
                   ("New Conversation", timestamp, timestamp))
        conn.commit()
        return cur.lastrowid
    
    def load_conversations(self):
        self.conversations_list.clear()
        cur.execute("SELECT id, title FROM conversations ORDER BY updated_at DESC LIMIT 50")
        for conv_id, title in cur.fetchall():
            self.conversations_list.addItem(f"{conv_id}: {title[:30]}...")
    
    def switch_conversation(self, item):
        conv_id = int(item.text().split(":")[0])
        self.current_conversation_id = conv_id
        self.load_conversation_history()
    
    def load_conversation_history(self):
        self.chat_display.clear()
        messages = get_conversation_history(self.current_conversation_id)
        for msg in messages:
            role_color = "#00d4aa" if msg["role"] == "assistant" else "#61dafb"
            self.chat_display.append(f'<span style="color:{role_color}; font-weight:bold;">{msg["role"].title()}:</span> {msg["content"]}<br>')
    
    def send_message(self):
        user_input = self.input_field.text().strip()
        if not user_input:
            return
            
        self.input_field.clear()
        self.send_button.setEnabled(False)
        
        # Display user message
        self.chat_display.append(f'<span style="color:#61dafb; font-weight:bold;">You:</span> {user_input}<br>')
        
        # Save user message
        save_message(self.current_conversation_id, "user", user_input)
        
        # Process message with enhanced features
        processed_input = self.process_enhanced_input(user_input)
        
        # Get conversation context
        messages = [{"role": "system", "content": self.get_system_prompt()}]
        messages.extend(get_conversation_history(self.current_conversation_id, 20))
        messages.append({"role": "user", "content": processed_input})
        
        # Start model thread
        self.model_thread = ModelThread(messages, self.current_conversation_id)
        self.model_thread.response_chunk.connect(self.on_response_chunk)
        self.model_thread.response_complete.connect(self.on_response_complete)
        self.model_thread.start()
    
    def process_enhanced_input(self, user_input):
        """Process user input with enhanced capabilities"""
        processed = strip_pii(user_input)
        
        # Handle special commands
        if processed.lower().startswith("search:"):
            query = processed[7:].strip()
            search_results = mcp.web_search(query, limit=5)
            if search_results:
                processed += f"\n\nWeb search results for '{query}':\n{json.dumps(search_results, indent=2)}"
        
        elif processed.lower().startswith("code:"):
            # Extract code for analysis
            code_content = processed[5:].strip()
            if code_content:
                # Detect language
                language = self.detect_language(code_content)
                analysis = mcp.analyze_code(code_content, language, "syntax")
                if analysis:
                    processed += f"\n\nCode analysis results:\n{json.dumps(analysis, indent=2)}"
        
        elif processed.lower().startswith("system:"):
            component = processed[7:].strip() or "cpu"
            system_info = mcp.get_system_info(component)
            if system_info:
                processed += f"\n\nSystem information ({component}):\n{json.dumps(system_info, indent=2)}"
        
        return processed
    
    def detect_language(self, code):
        """Simple language detection"""
        if "def " in code or "import " in code:
            return "python"
        elif "function " in code or "const " in code or "let " in code:
            return "javascript"
        elif "#include" in code or "int main" in code:
            return "c"
        elif "public class" in code or "System.out" in code:
            return "java"
        else:
            return "text"
    
    def get_system_prompt(self):
        return f"""You are {cfg['personality']['name']}, an advanced personal AI assistant with the following capabilities:

**Core Traits:** {', '.join(cfg['personality']['traits'])}
**Response Style:** {cfg['personality']['response_style']}

**Available Tools via MCP:**
- Web search for current information
- Code analysis and suggestions
- System monitoring and information
- File operations and management

**Context:** You have access to conversation history and can remember previous discussions. You can search the web, analyze code, check system status, and help with various tasks. Always be helpful, accurate, and respect user privacy.

**Current DateTime:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Respond naturally and use the available tools when appropriate to provide the most helpful and accurate information."""
    
    def on_response_chunk(self, chunk):
        """Handle streaming response chunks"""
        cursor = self.chat_display.textCursor()
        cursor.movePosition(cursor.MoveOperation.End)
        cursor.insertText(chunk)
        self.chat_display.setTextCursor(cursor)
    
    def on_response_complete(self, response):
        """Handle completed response"""
        self.chat_display.append("<br>")
        self.send_button.setEnabled(True)
        
        # Update conversation title if it's the first exchange
        cur.execute("SELECT COUNT(*) FROM messages WHERE conversation_id=?", (self.current_conversation_id,))
        if cur.fetchone()[0] <= 2:  # First user message and first assistant response
            title = response[:50] + "..." if len(response) > 50 else response
            title = re.sub(r'[<>"/\\|?*]', '', title)  # Clean title
            cur.execute("UPDATE conversations SET title=?, updated_at=? WHERE id=?",
                       (title, int(time.time()), self.current_conversation_id))
            conn.commit()
            self.load_conversations()
    
    def setup_tray(self):
        """Setup system tray"""
        if not cfg["ui"]["tray_enabled"]:
            return
            
        self.tray = QSystemTrayIcon()
        self.tray.setIcon(QIcon("/usr/share/icons/hicolor/64x64/apps/neo-assistant.svg"))
        self.tray.setToolTip("Neo AI Assistant")
        
        menu = QMenu()
        
        show_action = QAction("Show Neo", self)
        new_chat_action = QAction("New Chat", self)
        settings_action = QAction("Settings", self)
        quit_action = QAction("Quit", self)
        
        menu.addAction(show_action)
        menu.addAction(new_chat_action)
        menu.addSeparator()
        menu.addAction(settings_action)
        menu.addSeparator()
        menu.addAction(quit_action)
        
        self.tray.setContextMenu(menu)
        
        # Connect signals
        show_action.triggered.connect(self.show)
        new_chat_action.triggered.connect(self.new_chat)
        settings_action.triggered.connect(lambda: self.tabs.setCurrentIndex(1))
        quit_action.triggered.connect(QApplication.quit)
        
        self.tray.activated.connect(self.tray_activated)
        self.tray.show()
    
    def tray_activated(self, reason):
        if reason == QSystemTrayIcon.ActivationReason.Trigger:
            if self.isVisible():
                self.hide()
            else:
                self.show()
                self.raise_()
                self.activateWindow()
    
    def new_chat(self):
        self.current_conversation_id = self.create_new_conversation()
        self.chat_display.clear()
        self.load_conversations()
    
    def closeEvent(self, event):
        if cfg["ui"]["tray_enabled"]:
            event.ignore()
            self.hide()
        else:
            event.accept()

def main():
    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(False)
    
    # Set application properties
    app.setApplicationName("Neo AI Assistant")
    app.setApplicationVersion("2.0")
    app.setOrganizationName("Neo AI")
    
    # Create main window
    neo = NeoMainWindow()
    
    # Show window
    neo.show()
    
    # Setup global hotkey (if supported)
    try:
        import keyboard
        def toggle_neo():
            if neo.isVisible():
                neo.hide()
            else:
                neo.show()
                neo.raise_()
                neo.activateWindow()
        
        keyboard.add_hotkey('super+shift+n', toggle_neo)
    except ImportError:
        pass  # Keyboard module not available
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
'''))
PY

# Desktop entry with enhanced features
cat >/usr/share/applications/neo-assistant.desktop <<'DESKTOP'
[Desktop Entry]
Name=Neo AI Assistant
Comment=Advanced Local Personal AI with MCP Integration
Exec=/usr/local/neo-assistant/venv/bin/python /usr/local/neo-assistant/neo_assistant.py
Icon=neo-assistant
Terminal=false
Type=Application
Categories=Utility;AI;Development;
Keywords=AI;Assistant;Chat;MCP;Local;
StartupNotify=true
DESKTOP

# Autostart
cat >/etc/xdg/autostart/neo-assistant.desktop <<'AUTO'
[Desktop Entry]
Type=Application
Name=Neo Assistant
Exec=/usr/local/neo-assistant/venv/bin/python /usr/local/neo-assistant/neo_assistant.py
X-GNOME-Autostart-enabled=true
Hidden=false
AUTO

# ------------------------------------------------------------
# 5. Setup "cyber" user wallpaper automation
# ------------------------------------------------------------
echo "[neo-ai] Setting up wallpaper automation for user 'cyber'‚Ä¶"

# Cat API wallpaper script
cat >/usr/local/bin/neo-wallpaper.sh <<'WALLPAPER'
#!/bin/bash
set -euo pipefail

USER_HOME="/home/cyber"
WALLPAPER_DIR="$USER_HOME/.local/share/neo-wallpapers"
CURRENT_WALLPAPER="$WALLPAPER_DIR/current-cat.jpg"

# Create directories if they don't exist
mkdir -p "$WALLPAPER_DIR"

# Function to get random cat image
get_cat_wallpaper() {
    echo "Fetching new cat wallpaper..."
    
    # Try different cat API endpoints
    APIS=(
        "https://api.thecatapi.com/v1/images/search?size=full&mime_types=jpg"
        "https://cataas.com/cat?width=1920&height=1080"
        "https://placekitten.com/1920/1080"
    )
    
    for API in "${APIS[@]}"; do
        if [[ "$API" == *"thecatapi"* ]]; then
            # TheCatAPI returns JSON
            IMG_URL=$(curl -s "$API" | jq -r '.[0].url' 2>/dev/null || echo "")
            if [[ -n "$IMG_URL" && "$IMG_URL" != "null" ]]; then
                curl -s "$IMG_URL" -o "$CURRENT_WALLPAPER" && break
            fi
        else
            # Direct image URLs
            curl -s "$API" -o "$CURRENT_WALLPAPER" && break
        fi
    done
    
    # Verify we got a valid image
    if [[ -f "$CURRENT_WALLPAPER" ]] && file "$CURRENT_WALLPAPER" | grep -q "image"; then
        echo "Successfully downloaded cat wallpaper"
        return 0
    else
        echo "Failed to download cat wallpaper, using fallback"
        # Create a simple gradient fallback
        convert -size 1920x1080 gradient:'#1e3a8a-#3730a3' "$CURRENT_WALLPAPER" 2>/dev/null || true
        return 1
    fi
}

# Function to set wallpaper based on desktop environment
set_wallpaper() {
    local wallpaper_path="$1"
    
    # Detect and set wallpaper for different desktop environments
    if command -v gsettings >/dev/null 2>&1; then
        # GNOME/Ubuntu
        gsettings set org.gnome.desktop.background picture-uri "file://$wallpaper_path"
        gsettings set org.gnome.desktop.background picture-uri-dark "file://$wallpaper_path"
    fi
    
    if command -v plasma-apply-wallpaperimage >/dev/null 2>&1; then
        # KDE Plasma
        plasma-apply-wallpaperimage "$wallpaper_path"
    fi
    
    if command -v xfconf-query >/dev/null 2>&1; then
        # XFCE
        xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/workspace0/last-image -s "$wallpaper_path"
    fi
    
    if command -v pcmanfm >/dev/null 2>&1; then
        # LXDE
        pcmanfm --set-wallpaper "$wallpaper_path"
    fi
    
    if command -v feh >/dev/null 2>&1; then
        # Generic X11 with feh
        feh --bg-scale "$wallpaper_path"
    fi
    
    echo "Wallpaper set to: $wallpaper_path"
}

# Main execution
main() {
    echo "Neo AI Wallpaper Manager - Setting cat wallpaper..."
    
    # Get new cat wallpaper
    if get_cat_wallpaper; then
        # Set as wallpaper
        set_wallpaper "$CURRENT_WALLPAPER"
        echo "Cat wallpaper successfully applied!"
    else
        echo "Using existing or fallback wallpaper"
        if [[ -f "$CURRENT_WALLPAPER" ]]; then
            set_wallpaper "$CURRENT_WALLPAPER"
        fi
    fi
}

# Run main function
main "$@"
WALLPAPER
chmod +x /usr/local/bin/neo-wallpaper.sh

# Install dependencies for wallpaper script
apt-get install -y jq imagemagick feh curl

# Add line to cyber user's bashrc
if id "cyber" &>/dev/null; then
    echo "[neo-ai] Adding wallpaper automation to cyber user's bashrc..."
    CYBER_BASHRC="/home/cyber/.bashrc"
    
    # Create bashrc if it doesn't exist
    if [[ ! -f "$CYBER_BASHRC" ]]; then
        touch "$CYBER_BASHRC"
        chown cyber:cyber "$CYBER_BASHRC"
    fi
    
    # Add the wallpaper line if not already present
    if ! grep -q "neo-wallpaper.sh" "$CYBER_BASHRC"; then
        echo "" >> "$CYBER_BASHRC"
        echo "# Neo AI Assistant - Daily cat wallpaper" >> "$CYBER_BASHRC"
        echo "/usr/local/bin/neo-wallpaper.sh &" >> "$CYBER_BASHRC"
        chown cyber:cyber "$CYBER_BASHRC"
    fi
    
    # Also create a daily cron job for wallpaper updates
    echo "0 9 * * * /usr/local/bin/neo-wallpaper.sh" | crontab -u cyber -
fi

# ------------------------------------------------------------
# 6. Enhanced Model Downloads and Optimizations
# ------------------------------------------------------------
echo "[neo-ai] Pre-downloading enhanced AI models‚Ä¶"

# Function to pull models safely
pull_model_safe() {
    local model="$1"
    echo "Pulling model: $model"
    timeout 300 ollama pull "$model" || echo "Model $model pull failed or timed out"
}

# Start ollama service
systemctl start ollama.service || true
sleep 5

# Pull enhanced models
pull_model_safe "phi3.5:latest"
pull_model_safe "llama3.1:8b"
pull_model_safe "qwen2.5:7b"
pull_model_safe "deepseek-coder:6.7b"
pull_model_safe "nomic-embed-text:latest"  # For embeddings

# ------------------------------------------------------------
# 7. Additional Enhancements and Integrations
# ------------------------------------------------------------
echo "[neo-ai] Installing additional enhancements‚Ä¶"

# Web interface for Neo (optional)
cat >/opt/neo-mcp/web-interface.py <<'WEB'
#!/usr/bin/env python3
import os, sys
from flask import Flask, render_template, request, jsonify, send_static_file
import requests, json

app = Flask(__name__)
app.secret_key = "neo-ai-web-interface-2024"

@app.route('/')
def index():
    return '''
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo AI Web Interface</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3a8a, #3730a3);
            color: white; min-height: 100vh; padding: 20px;
        }
        .container {
            max-width: 1200px; margin: 0 auto; background: rgba(255,255,255,0.1);
            border-radius: 20px; padding: 30px; backdrop-filter: blur(10px);
        }
        .header { text-align: center; margin-bottom: 30px; }
        .chat-container {
            background: rgba(0,0,0,0.2); border-radius: 15px;
            height: 500px; overflow-y: auto; padding: 20px; margin-bottom: 20px;
        }
        .input-container {
            display: flex; gap: 10px;
        }
        input[type="text"] {
            flex: 1; padding: 15px; border-radius: 10px; border: none;
            background: rgba(255,255,255,0.1); color: white;
            font-size: 16px;
        }
        input[type="text"]::placeholder { color: rgba(255,255,255,0.7); }
        button {
            padding: 15px 30px; background: #10b981; border: none;
            border-radius: 10px; color: white; font-weight: bold;
            cursor: pointer; transition: all 0.3s;
        }
        button:hover { background: #059669; transform: translateY(-2px); }
        .message {
            margin: 10px 0; padding: 15px; border-radius: 10px;
            animation: fadeIn 0.5s ease-in;
        }
        .user-message { background: rgba(99, 218, 251, 0.2); }
        .ai-message { background: rgba(16, 185, 129, 0.2); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .status { text-align: center; margin: 10px 0; opacity: 0.7; }
        .features {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px; margin-top: 30px;
        }
        .feature {
            background: rgba(255,255,255,0.05); padding: 20px;
            border-radius: 15px; text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Neo AI Assistant</h1>
            <p>Advanced Local AI with MCP Integration</p>
        </div>
        
        <div class="chat-container" id="chatContainer">
            <div class="message ai-message">
                Hello! I'm Neo, your advanced AI assistant. I can help with web searches, code analysis, system information, and much more. What would you like to explore today?
            </div>
        </div>
        
        <div class="input-container">
            <input type="text" id="userInput" placeholder="Ask Neo anything... Try 'search: latest AI news' or 'code: def hello():'">
            <button onclick="sendMessage()">Send</button>
        </div>
        
        <div class="status" id="status"></div>
        
        <div class="features">
            <div class="feature">
                <h3>üåê Web Search</h3>
                <p>Real-time web search integration</p>
            </div>
            <div class="feature">
                <h3>üíª Code Analysis</h3>
                <p>Intelligent code review and suggestions</p>
            </div>
            <div class="feature">
                <h3>üìä System Monitoring</h3>
                <p>Real-time system information and metrics</p>
            </div>
            <div class="feature">
                <h3>üîí Privacy First</h3>
                <p>Local processing with encryption</p>
            </div>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chatContainer');
        const userInput = document.getElementById('userInput');
        const status = document.getElementById('status');

        function addMessage(content, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'ai-message'}`;
            messageDiv.innerHTML = `<strong>${isUser ? 'You' : 'Neo'}:</strong> ${content}`;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            addMessage(message, true);
            userInput.value = '';
            status.textContent = 'Neo is thinking...';

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });

                const data = await response.json();
                addMessage(data.response || 'Sorry, I encountered an error.');
            } catch (error) {
                addMessage('Sorry, I'm having trouble connecting right now.');
            } finally {
                status.textContent = '';
            }
        }

        userInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') sendMessage();
        });
    </script>
</body>
</html>
    '''

@app.route('/api/chat', methods=['POST'])
def chat():
    try:
        message = request.json.get('message', '')
        # Here you would integrate with your Neo AI backend
        # For now, return a simple response
        response = f"Echo: {message} (Web interface integration pending)"
        return jsonify({'response': response})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
WEB
chmod +x /opt/neo-mcp/web-interface.py

# ------------------------------------------------------------
# 8. Final System Optimizations
# ------------------------------------------------------------
echo "[neo-ai] Applying final optimizations‚Ä¶"

# Optimize for AI workloads
echo 'vm.swappiness=10' >> /etc/sysctl.conf
echo 'net.core.rmem_max=16777216' >> /etc/sysctl.conf
echo 'net.core.wmem_max=16777216' >> /etc/sysctl.conf

# Create systemd service for MCP
cat >/etc/systemd/system/neo-mcp.service <<'SERVICE'
[Unit]
Description=Neo AI MCP Server
After=docker.service
Requires=docker.service

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=/opt/neo-mcp
ExecStart=/usr/bin/docker-compose up -d
ExecStop=/usr/bin/docker-compose down
TimeoutStartSec=0

[Install]
WantedBy=multi-user.target
SERVICE

systemctl enable neo-mcp.service

# Performance tuning for AI models
cat >/etc/modprobe.d/neo-ai.conf <<'MODPROBE'
# Optimize for AI workloads
options nvidia NVreg_PreserveVideoMemoryAllocations=1
options nvidia NVreg_TemporaryFilePath=/tmp
MODPROBE

# Create update script
cat >/usr/local/bin/neo-update.sh <<'UPDATE'
#!/bin/bash
set -euo pipefail

echo "Neo AI Assistant Update Script"

# Update system packages
apt-get update && apt-get upgrade -y

# Update Docker containers
cd /opt/neo-mcp
docker-compose pull
docker-compose up -d

# Update Ollama models
ollama pull smollm2:latest

# Update Python dependencies
/usr/local/neo-assistant/venv/bin/pip install --upgrade pip
/usr/local/neo-assistant/venv/bin/pip install --upgrade -r requirements.txt 2>/dev/null || true

echo "Neo AI Assistant updated successfully!"
UPDATE
chmod +x /usr/local/bin/neo-update.sh

# Create requirements.txt for future updates
cat >/usr/local/neo-assistant/requirements.txt <<'REQUIREMENTS'
PyQt6>=6.4.0
requests>=2.28.0
pyyaml>=6.0
beautifulsoup4>=4.11.0
psycopg2-binary>=2.9.0
redis>=4.3.0
elasticsearch>=8.0.0
cryptography>=3.4.0
pillow>=9.0.0
nltk>=3.7.0
sentence-transformers>=2.2.0
numpy>=1.21.0
pandas>=1.4.0
matplotlib>=3.5.0
flask>=2.2.0
keyboard>=0.13.5
REQUIREMENTS

echo "[neo-ai] === Neo AI Assistant Enhanced Setup Complete! ==="
echo ""
echo "üéâ Your enhanced Neo AI Assistant is now installed with:"
echo "   ‚úÖ Advanced MCP Server with Docker"
echo "   ‚úÖ PostgreSQL, Redis, and Elasticsearch integration"
echo "   ‚úÖ Enhanced GUI with multiple AI models"
echo "   ‚úÖ Web search, code analysis, and system monitoring"
echo "   ‚úÖ Privacy-focused with encryption at rest"
echo "   ‚úÖ Daily cat wallpapers for user 'cyber'"
echo "   ‚úÖ System tray integration and global hotkeys"
echo "   ‚úÖ Web interface available at http://localhost:5000"
echo ""
echo "üöÄ To start:"
echo "   sudo systemctl start ollama neo-mcp"
echo "   /usr/local/neo-assistant/venv/bin/python /usr/local/neo-assistant/neo_assistant.py"
echo ""
echo "üîß Update with: /usr/local/bin/neo-update.sh"
echo "üìÅ Config: /etc/neo-assistant/policy.yaml"
echo "üåê MCP Server: http://localhost:3000"
echo "üíæ Data: ~/.local/share/neo-assistant/"
echo ""
echo "Press Super+Shift+N to toggle Neo Assistant anytime!"